#!/usr/bin/env python3
#
# Shows status of compute job. Reports real-time status by
# tracking files generated by the job.
#
import argparse
import inotify.adapters
import os
import copy
import sys
import glob
from datetime import datetime
from pprint import pprint

def report(pending, all_outputs, partial=None, full=None):
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if partial:
        print(f"{ts} Total: {len(all_outputs)}, Pending: {len(pending)} Step: {partial}")
    elif full:
        print(f"{ts} Total: {len(all_outputs)}, Pending: {len(pending)} Done: {full}")
    else:
        print(f"{ts} Total: {len(all_outputs)}, Pending: {len(pending)}")

parser = argparse.ArgumentParser()
parser.add_argument('-1', '--once', action='store_true',
    help="""Show job status and exit""")
parser.add_argument("--output_path", type=str, default='/shared/output',
    help="""Directory where the output is being generated. This can be the
    directory corresponding to a mask region, or the entire output.""")
args = parser.parse_args()

all_outputs = []

# Find all done lists in the output dir
cwd = os.getcwd()
os.chdir(args.output_path)
donelists = glob.glob("**/done.list", recursive=True)
os.chdir(cwd)

for this_list in donelists:
    # paths in lists are relative
    donedir = os.path.split(this_list)[0]
    donedir = os.path.join(args.output_path, donedir)
    full_path = os.path.join(donedir, 'done.list')
    print(f'Monitoring: {donedir}')
    dir_filelist = list(map(lambda x:os.path.join(donedir,x.strip()), open(full_path,'r').readlines()))
    all_outputs += dir_filelist

# Eliminate any duplicates (can happen due to user errors)
all_outputs = list(set(all_outputs))

pending = copy.copy(all_outputs)
# Check which ones are done
for filename in all_outputs:
    if os.path.isfile(filename):
        pending.remove(filename)
report(pending, all_outputs)

if args.once or len(pending)==0:
    sys.exit(0)

tree_watch = inotify.adapters.InotifyTree(args.output_path)

for event in tree_watch.event_gen():
    if not event:
        continue
    if(len(event[1])==1) and (event[1][0] == 'IN_CREATE'):
        full_path = os.path.join(event[2], event[3])
        if full_path in pending:
            #print(f'Removing: {full_path}')
            pending.remove(full_path)
            report(pending, all_outputs, full=full_path)
        else:
            report(pending, all_outputs, partial=full_path)
    if len(pending)==0:
        break
